//---------------------------------------------------------------------------
/*********************************************************************
	Login		: rosskw1
	Model Element	: Queue
  Generated Date	: Mon, 21, Apr 2008  
	File Path	: Queue.cppmy

  Description: This class uses a boost timed-mutex to provide a means
  by which a user can de-queue messages and have an automatic timeout
  so that if a message isn't de-queued within a user-specified timout,
  control is returned to the user with a NULL pointer.

  For the producer, messages are dropped in the queue and control is
  returned, with a status of "true". If the queue is full, a return
  value of "false" is returned.  The user could then try to queue the
  message again.
*********************************************************************/


#include "Queue.h"
#include "boost/thread.hpp"
#include <boost/interprocess/mapped_region.hpp>
#include <boost/interprocess/sync/scoped_lock.hpp>
#include "boost/date_time/posix_time/posix_time.hpp"
#include <sys\timeb.h>


using namespace boost::interprocess;

//---------------------------------------------------------------------------


//Constructor

//---------------------------------------------------------------------------
InterprocessQueue::InterprocessQueue(char* queueName, unsigned int maxMessageSizeInBytes, unsigned long int maxNumberOfMessages) : 
exitFlag(false), queueState(QueueSynchronizing), QueueInitializationSemaphore(0), maxMsgSize(maxMessageSizeInBytes + sizeof(unsigned int)),
maxMsgs(maxNumberOfMessages), totalQueueSize(maxMessageSizeInBytes * maxNumberOfMessages)
{
  bool createFlag = false;

  strcpy(QueueName, queueName);

  try
  {
    //Erase previous shared memory
    shared_memory_object::remove(queueName);

    //Create a shared memory object.
    shm1 = new shared_memory_object
      (open_or_create //open or create
       ,queueName     //name
       ,read_write    //read-write mode
       );

    //Set size
    shm1->truncate(totalQueueSize);

    //Map the whole shared memory in this process
    region1 = new mapped_region
      (*shm1                       //What to map
      ,read_write   //Map it as read-write
      );

    //Get the address of the mapped region
    addr1       = region1->get_address();

    //Construct the shared structure in memory
    myQueue = new (addr1) unsigned char[totalQueueSize];


    sprintf(ControlDataName, "%s%s", queueName, "ControlData");
    //Erase previous shared memory
    shared_memory_object::remove(ControlDataName);

    //Create a shared memory object.
    shm2 = new shared_memory_object
      (open_or_create //open or create
       ,ControlDataName             //name
       ,read_write    //read-write mode
       );

    //Set size
    shm2->truncate(sizeof(SharedMemoryQueueControlData));

    //Map the whole shared memory in this process
    region2 = new mapped_region
      (*shm2                       //What to map
      ,read_write   //Map it as read-write
      );

    //Get the address of the mapped region
    addr2       = region2->get_address();

    //Construct the shared structure in memory
    myControlData = new (addr2) SharedMemoryQueueControlData;

    myControlData->CurrentReadSlot = 0;
    myControlData->CurrentWriteSlot = 0;
    myControlData->NumberMessagesInQueue = 0;
    myControlData->InterfaceStatus = false;
  }
  catch (...)
  {
    //char s[300];
    //sprintf(s, "InterprocessQueue-Server-EXCEPTION\n\n");
    //LogMessage(s, 0);
  };
}

//---------------------------------------------------------------------------

// Destructor

//---------------------------------------------------------------------------

InterprocessQueue::~InterprocessQueue() 
{
  //Erase shared memory
  exitFlag = true;
  myControlData->myMutex.post();  // Wake "getMessage".
  myControlData->myDataAccessMutex.unlock();
  myControlData->addMessageMutex.unlock();

  shared_memory_object::remove(QueueName);
  delete region1;
  delete shm1;

  shared_memory_object::remove(ControlDataName);
  delete region2;
  delete shm2;
}

//**********************************************************************************************************************
//
//  Name: SynchronizeQueueUsers
// 
//  Purpose: This method writes a unique value that's generated using the lower bits of what's returned from "ftime",
//           into a location in shared memory.  It then checks periodically to see if that value has changed, which 
//           indicates that the other user has written its unique value in the same shared memory location.  Once 
//           there's a difference, the Queue is marked as synchronized and the original unique value is written back
//           to the shared memory location to ensure that the other user detects a different value than they last 
//           wrote to the location.
//
//**********************************************************************************************************************

bool InterprocessQueue::SynchronizeQueueUsers(void)
{
  unsigned long uniqueValue, newValue;
  timeb t;
  //char s[200];

  queueState = QueueSynchronizing;
  ftime(&t);
  srand(t.millitm);

  if (exitFlag == true)
    return(false);

  { // Start of scope.
    scoped_lock<interprocess_mutex> lock(myControlData->myDataAccessMutex); //This lock protects the queue itself.
    myControlData->InterfaceStatus = false; // Declare interface "DOWN" so other side knows.
    uniqueValue = myControlData->UniqueValue = (((unsigned long)rand()) * 1000) % 1000000;
  } // End of scope.

  QueueInitializationSemaphore.timed_wait(boost::get_system_time() + boost::posix_time::seconds(0) + 
    boost::posix_time::microseconds(uniqueValue));

  { // Start of scope.
    scoped_lock<interprocess_mutex> lock(myControlData->myDataAccessMutex); //This lock protects the queue itself.
    newValue = myControlData->UniqueValue;
  } // End of scope.

  if (newValue != uniqueValue)
  {
    { // Start of scope.
      scoped_lock<interprocess_mutex> lock(myControlData->myDataAccessMutex); //This lock protects the queue itself.

      // Now change the shared memory location to force the other process that this process is ready.
      myControlData->UniqueValue = uniqueValue;
      myControlData->InterfaceStatus = true; // Declare interface "UP" so other side knows.
    } // End of scope.

    queueState = QueueSynchronized;
    return(true);
  }

  return(false);
}

InterprocessQueue::QueueState InterprocessQueue::getQueueState(void)
{
  QueueState qs;

  { // Start of scope.
    scoped_lock<interprocess_mutex> lock(myControlData->myDataAccessMutex); //This lock protects the queue itself.
    qs = queueState;
  } // End of scope.
  return(qs);
}

//---------------------------------------------------------------------------
//
// addMessage
//
// User adds messages by calling "addMessage".  Returns "true" if
// successful (queue not full) or "false" if unsuccessful (queue full).
//
//---------------------------------------------------------------------------
        
bool InterprocessQueue::addMessage(unsigned char* message, unsigned int messageSizeInBytes)
{
  //char s[200];
  unsigned char* ptr;

  if (exitFlag == true)
    return(false);

  if (queueState == QueueSynchronizing)
    return(false);

  try
  {
    { // Start of Scope.
      // Get the mutex just long enough to add the message to the queue.
      scoped_lock<interprocess_mutex> lock(myControlData->myDataAccessMutex); //This lock protects the queue itself.

      // Check to see if the the "Consumer" has declared the interface "DOWN".  If so, we'll go back into "Synchronizing" state.
      if (myControlData->InterfaceStatus == false)
        return(false);

      if (myControlData->NumberMessagesInQueue >= maxMsgs)
      {
        return(false);
      }
    //sprintf(s, "addMsg-Slot=%u, In Q=%u\n\n", myQueue->CurrentWriteSlot, myQueue->NumberMessagesInQueue);
    //LogMessage(s, 0);
      ptr = &(myQueue[myControlData->CurrentWriteSlot*maxMsgSize]);
      ((unsigned int*)ptr)[0] = messageSizeInBytes; // Put the # of Message-bytes at front of message.
      ptr += sizeof(unsigned int);  // Set the pointer past the byte-count, to the message portion of the buffer.

      memcpy(ptr, message, messageSizeInBytes);

      myControlData->NumberMessagesInQueue++;

      ++myControlData->CurrentWriteSlot %= maxMsgs;
    
      myControlData->myMutex.post();  // Wake "getMessage".
//sprintf(s, "addMsg-Q'd Msg#=%u\n\n", myControlData->NumberMessagesInQueue);
//LogMessage(s, 0);

      return(true); // Message was queued
    } // End of Scope.
  }
  catch (...)
  {
  };
  return(false);
}

bool InterprocessQueue::timedAddMessage(unsigned char* message, unsigned int messageSizeInBytes, 
                                        unsigned int timeoutSecs, unsigned long int timeoutMicroSecs)
{
  //void* m_Ptr;
  //char s[200];

  // Just in case this function gets invoked during shutdown.
  if (exitFlag == true)
    return(NULL);

  try
  {
    // Check to see if there's a message already waiting on the Queue.  If so, we just return it.
    if ( addMessage(message, messageSizeInBytes) == true)
    {
 //sprintf(s, "Timedadd-addedMsg-count=%u\n\n", myControlData->NumberMessagesInQueue);
 //LogMessage(s, 0);
      return(true);
    }
 //sprintf(s, "Timedadd-didn't addMsg-count=%u\n\n", myControlData->NumberMessagesInQueue);
 //LogMessage(s, 0);

    // The Queue is full, so now we have to wait for either the queue to be unlocked or the timeout occurs.
    // Block on the mutex until either a message is taken out of the queue (getMessage function unlocks the 
    // mutex after dropping a message in the queue), or the timer expires.
    myControlData->addMessageMutex.timed_lock(boost::get_system_time() + boost::posix_time::seconds(timeoutSecs) + 
                                        boost::posix_time::microseconds(timeoutMicroSecs));

 if (addMessage(message, messageSizeInBytes) == true)
 {
 //sprintf(s, "Timedadd-addedMsg-count=%u\n\n", myControlData->NumberMessagesInQueue);
 //LogMessage(s, 0);
 return(true);
 }
 else
 {
 //sprintf(s, "Timedadd-didn't addMsg-count=%u\n\n", myControlData->NumberMessagesInQueue);
 //LogMessage(s, 0);
 return(false);
 }

    //return( addMessage(message, messageSizeInBytes) );
  }
  catch(...)
  {
    return(false);
  };

  return(false);
}

//---------------------------------------------------------------------------
        
// getMessage

// Immediately check to see if the thread should exit.  Check to see if there
// is a message in the queue and, if so, return it to the user.  If not, wait
// up to the user-defined timeout.  If a message becomes available in the
// queue within the timeout period, return the message.  If not, return a 
// NULL pointer.
//---------------------------------------------------------------------------

bool InterprocessQueue::getMessage(unsigned char* msg, unsigned int timeoutSecs, unsigned long int timeoutMicroSecs)
{
  //char s[200];
  //void* m_Ptr;

  // Just in case this function gets invoked during shutdown.
  if (exitFlag == true)
  {
    //sprintf(s, "getMsg-#1\n\n");
    //LogMessage(s, 0);
    return(false);
  }

  try
  {
    // Check to see if there's a message already waiting on the Queue.  If so, we just return it.
//sprintf(s, "getMsg-Call getMsg\n\n");
//LogMessage(s, 0);
//    if ( (CheckForMessage(msg)) == true)
//{
////sprintf(s, "getMsg-Return=true\n\n");
////LogMessage(s, 0);
//      return(true);
//}

    // There were no items in the Queue, so now we have to wait for either the queue to be unlocked or the timeout occurs.
    // Block on the mutex until either a message is received in the queue (addMessage function unlocks the mutex after dropping a message
    // in the queue), or the timer expires.
    //sprintf(s, "getMsg-#3 Starting Wait-Usec=%u\n\n", timeoutMicroSecs);
    //LogMessage(s, 0);
    
    //{
    //  scoped_lock<interprocess_mutex> myDataAccessLock(myControlData->myDataAccessMutex); //This lock protects the queue itself.
    //  if (myControlData->NumberMessagesInQueue == 0)
    //    myControlData->myMutex.try_lock();
    //}

      if (myControlData->myMutex.timed_wait(boost::get_system_time() + boost::posix_time::seconds(timeoutSecs) + 
            boost::posix_time::microseconds(timeoutMicroSecs)) == true)
      {
  if (queueState == QueueSynchronizing)
  {
    //sprintf(s, "CheckForMessage-#1\n\n");
    //LogMessage(s, 0);
    return(false);
  }

  //sprintf(s, "CheckForMessage-Q Synchronized-, #msgs=%u\n\n", myControlData->NumberMessagesInQueue);
  //LogMessage(s, 0);
  scoped_lock<interprocess_mutex> myDataAccessLock(myControlData->myDataAccessMutex); //This lock protects the queue itself.

  // Check to see if the the "Producer" has declared the interface "DOWN".  If so, we'll go back into "Synchronizing" state.
  if (myControlData->InterfaceStatus == false)
  {
    //sprintf(s, "CheckForMessage-#2  In Q=%u\n\n", myControlData->NumberMessagesInQueue);
    //LogMessage(s, 0);
    return(false);
  }

  // Check to see if there's a Message in the list   
  if (myControlData->NumberMessagesInQueue > 0)
  {      
    // Get the first message in the list.                                  
    //m_Ptr = &(myQueue[myControlData->CurrentReadSlot*maxMsgSize]);  
    memcpy(msg, &(myQueue[myControlData->CurrentReadSlot*maxMsgSize]), maxMsgSize);

    // Remove the message from the list now so that the mutex can be unlocked prior to sending.  
    myControlData->NumberMessagesInQueue--; 
    
    ++myControlData->CurrentReadSlot %= maxMsgs;

    myControlData->addMessageMutex.unlock();
    //sprintf(s, "CheckMsg-DQ'd msg=%u\n\n", myControlData->NumberMessagesInQueue);
    //LogMessage(s, 0);

    return(true);
  }
  else
  {
    //sprintf(s, "CheckForMessage-#3 msg=%u\n\n", myControlData->NumberMessagesInQueue);
    //LogMessage(s, 0);
    return(false);
  }
        //sprintf(s, "getMsg-#4\n\n");
        //LogMessage(s, 0);
        //return( CheckForMessage(msg) );
      }
      else
      {
        //sprintf(s, "getMsg-#5\n\n");
        //LogMessage(s, 0);
        return(false);
      }
  }
  catch(...)
  {
    //sprintf(s, "getMsg-#7\n\n");
    //LogMessage(s, 0);
    return(false);
  };

//sprintf(s, "getMsg-#8\n\n");
//LogMessage(s, 0);
  return(false);
}


static struct timeb previousTime;
static double       previousCount;

        void InterprocessQueue::LogMessage(char* Msg, double count)
        {
          struct timeb  t;
          int           Hours, Mins, Secs;
          double        deltaTime, iterationsPerSecond, secs, milliSecs;

          ftime(&t);
          Secs = t.time % 86400; // 86400 = Seconds/24 hours
          Hours = Secs / 3600;
          Secs -= Hours * 3600;
          Mins = Secs / 60;
          Secs -= Mins * 60;

          if (previousTime.time == 0)
          {
            deltaTime = 0.0;
            iterationsPerSecond = 0.0;
          }
          else
          {
            secs = (t.time - previousTime.time);
            secs *= 1000.0;
            milliSecs = (t.millitm - previousTime.millitm);
            secs += milliSecs;
            deltaTime = secs / 1000.0;
            iterationsPerSecond = (count-previousCount) / deltaTime;
          }
          previousTime = t;
          previousCount = count;
  
          //TS = gmtime( &tt );
          printf("%02u:%02u:%02u.%03u-DT=%7.3f S, Iter/Sec=%10.3f : %s", Hours, Mins, Secs, t.millitm, deltaTime, iterationsPerSecond, Msg);
        }


